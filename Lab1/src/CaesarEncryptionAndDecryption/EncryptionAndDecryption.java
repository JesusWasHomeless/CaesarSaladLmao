package CaesarEncryptionAndDecryption;

import java.io.*;
import java.nio.charset.StandardCharsets;


public class EncryptionAndDecryption {
//Инициализация массивов под алфавит:
    private float[] alphabet1 = new float[64]; //Исходный алфавит, [А-Я, а-я]
    private float[] alphabet2 = new float[64]; //Алфавит на выходе

//=======================================================Метод шифрования алгоритмом Цезаря с задаваемым пользователем сдвигом - shift:=============================================

    public void encrypt (int shift) throws Exception{

        int letter; //индекс буквы

        //Открываем поток чтения файла и задаём для данного потока кодировку UTF-8:
        FileInputStream file = new FileInputStream("F:/ProjectFromGod1/Cryptography/Lab1/in.txt");
        InputStreamReader text = new InputStreamReader(file,"UTF-8");


        //Открываем поток записи с кодировкой UTF-8
        OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream("F:/ProjectFromGod1/Cryptography/Lab1/OutEncrypted.txt"), StandardCharsets.UTF_8);

        //Алгоритм шифрования:
        //1. Читаем файл посимвольно до конца. Конец и есть (-1)
        //2. Если у нас русскоязычная буква (Диапазон от 1040 до 1103, Ё не включена в диапазон), то инкрементируем количество этой буквы в массиве алфавит (считаем количество)
        //3. После делаем саму зашифровку с помощью сдвига. Если сдвигом мы вышли за грани алфавита русского, то циклим сдвиг на начало алфавита.
        //4. Знаки препинания не затрагиваются, иные буквы - тоже
        //5. После того как получили зашифрованую букву мы инкрементируем количество этой буквы в тексте во втором массиве алфавита
        //6. Запись символа в файл

        while ((letter=text.read())!=-1){
            if (letter>=1040&letter<=1103) {
                alphabet1[letter - 1040]++;
                letter += shift;
                if (letter > 1103) letter -= 64;
                alphabet2[letter - 1040]++;
            }
            writer.write(letter); //запись зашифрованного текста в файл
        }
        //Закрываем потоки
        text.close();
        file.close();
        writer.close();
    }

//==================================================================================================================================================================================
//=======================================================Метод дешифрирования алгоритмом Цезаря частотным анализом: ================================================================
    //Метод дешифрирования шифра Цезаря частотным анализом:
    public void  decrypt () throws Exception {

        //Инициализация массива для индексов, чьи частоты совпали
        int[] find = new int[64];

        //Открываем поток чтения и отправляем в него ЗАШИФРОВАННЫЙ!!! файл с кодировкой UTF-8:
        FileInputStream file = new FileInputStream("F:/ProjectFromGod1/Cryptography/Lab1/OutEncrypted.txt");
        InputStreamReader text = new InputStreamReader(file, "UTF-8");

        //Алгоритм для дешифрирования частотным анализом:
        //1. Определяем количество символов в файле
        //2. Определяем частоту каждой буквы: количество букв делим на количество всех символов
        //3. Сверяем частоты зашифрованного и незашифрованного алфавита
        //4. Совпавшие частоты заносим в отдельную таблицу (в данном случае, массив - find)
        //5. Расшифровка: если элемент - русскоязычная буква, то...
        // ...расшифрованная буква будет иметь значение find[letter-1040]+1040, где 1040 - самая первая буква,...
        //...а find[letter-1040] - буква, которая имеет совпавшие частоты с зашифрованным и исходным алфавитом

        //З.Ы. АЛГОРИТМ ЧАСТОТНОГО АНАЛИЗА НЕ ПОЗВОЛЯЕТ ПОЛНОСТЬЮ РАСШИФРОВАТЬ ТЕКСТ, МОГУТ БЫТЬ КОСЯКИ, И ЭТО НОРМАЛЬНО!
        //Кол-во символов в файле
        int SizeFile = file.available();

        //Определение частот для исходного и зашифрованного алфавита
        for (int i = 0; i < 64; i++) {
            alphabet1[i] = alphabet1[i] / SizeFile;
            alphabet2[i] = alphabet2[i] / SizeFile;
        }
        //если частота одного алфавита совпадает с другим, то заносим в массив индекс элемента
        for (int i = 0; i < 64; i++)
            for (int j = 0; j < 64; j++)
                if (alphabet2[i] == alphabet1[j]) find[i] = j;

        //Вывод массива индексов (для наглядности)
        for (int h = 0; h < 64; h++) System.out.println(find[h]);

        //Открываем поток записи с кодировкой UTF-8 итогового дешифрованного текста:
        OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream("F:/ProjectFromGod1/Cryptography/Lab1/OutDecrypted.txt"), StandardCharsets.UTF_8);

        int letter;

        while ((letter = text.read()) != -1) {
            if (letter >= 1040 & letter <= 1103) {
                letter = find[letter - 1040] + 1040;
            }
            writer.write(letter); //запись расшифрованного текста в файл
        }

        //Закрываем потоки:
        text.close();
        file.close();
        writer.close();

    }
//==================================================================================================================================================================================
}


